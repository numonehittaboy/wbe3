{"version":3,"file":"inputField-DFBRs3wP.js","sources":["../src/helpers/dom/placeCaretAtEnd.ts","../src/helpers/dom/documentFragmentToHTML.ts","../src/helpers/dom/findUpAttribute.ts","../src/helpers/dom/findUpTag.ts","../src/helpers/dom/getCaretPosNew.ts","../src/lib/richTextProcessor/combineSameEntities.ts","../src/lib/richTextProcessor/sortEntities.ts","../src/helpers/dom/getRichElementValue.ts","../src/helpers/dom/getRichValueWithCaret.ts","../src/helpers/dom/isInputEmpty.ts","../src/helpers/dom/compareNodes.ts","../src/helpers/dom/richInputHandler.ts","../src/helpers/dom/selectElementContents.ts","../src/lib/richTextProcessor/findConflictingEntity.ts","../src/lib/richTextProcessor/mergeEntities.ts","../src/lib/richTextProcessor/wrapDraftText.ts","../src/components/inputField.ts"],"sourcesContent":["/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport IS_TOUCH_SUPPORTED from '../../environment/touchSupport';\n\nexport default function placeCaretAtEnd(el: HTMLElement, ignoreTouchCheck = false, focus = true) {\n  if(IS_TOUCH_SUPPORTED && (!ignoreTouchCheck || (document.activeElement.tagName !== 'INPUT' && !(document.activeElement as HTMLElement).isContentEditable))) {\n    return;\n  }\n\n  focus && el.focus();\n  if(el instanceof HTMLInputElement) {\n    const length = el.value.length;\n    el.selectionStart = length;\n    el.selectionEnd = length;\n  } else {\n    const range = document.createRange();\n    range.selectNodeContents(el);\n    range.collapse(false);\n    const sel = window.getSelection();\n    sel.removeAllRanges();\n    sel.addRange(range);\n  }\n}\n\n(window as any).placeCaretAtEnd = placeCaretAtEnd;\n","import encodeEntities from '../string/encodeEntities';\n\nexport default function documentFragmentToHTML(fragment: DocumentFragment) {\n  return Array.from(fragment.childNodes).map((node) => {\n    return node.nodeType === node.TEXT_NODE ? encodeEntities(node.textContent) : (node as Element).outerHTML;\n  }).join('');\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nexport default function findUpAttribute(el: any, attribute: string): HTMLElement {\n  return el.closest(`[${attribute}]`);\n  /* if(el.getAttribute(attribute) !== null) return el; // 03.02.2020\n\n  while(el.parentElement) {\n    el = el.parentElement;\n    if(el.getAttribute(attribute) !== null)\n      return el;\n  }\n  return null; */\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nexport default function findUpTag(el: any, tag: string): HTMLElement {\n  return el.closest(tag);\n  /* if(el.tagName === tag) return el; // 03.02.2020\n\n  while(el.parentElement) {\n    el = el.parentElement;\n    if(el.tagName === tag)\n      return el;\n  }\n  return null; */\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport findUpAsChild from './findUpAsChild';\n\nexport default function getCaretPosNew(input: HTMLElement, anchor?: boolean): ReturnType<typeof getCaretPosF> & {selection: Selection} {\n  const selection = document.getSelection();\n  // let {focusNode: node, focusOffset: offset} = selection;\n  const node = selection[anchor ? 'anchorNode' : 'focusNode'];\n  const offset = selection[anchor ? 'anchorOffset' : 'focusOffset'];\n  if(!findUpAsChild(node, input) && node !== input) {\n    return {selection} as any;\n  }\n\n  return {...getCaretPosF(input, node, offset), selection};\n}\n\nexport function getCaretPosF(input: HTMLElement, node: Node, offset: number) {\n  if(node === input) {\n    const childNodes = input.childNodes;\n    const childNodesLength = childNodes.length;\n    if(childNodesLength && offset >= childNodesLength) {\n      node = childNodes[childNodesLength - 1];\n      offset = (node.textContent || (node as HTMLImageElement).alt || '').length;\n    } else {\n      node = childNodes[offset];\n      offset = 0;\n    }\n  }\n\n  return {node: node as ChildNode, offset};\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport {MessageEntity} from '../../layer';\n\nconst CAN_COMBINE_ENTITIES: Set<MessageEntity['_']> = new Set([\n  'messageEntityBold',\n  'messageEntityItalic',\n  'messageEntityCode',\n  'messageEntityPre',\n  'messageEntityUnderline',\n  'messageEntityStrike',\n  'messageEntityBlockquote',\n  'messageEntitySpoiler'\n]);\nexport default function combineSameEntities(entities: MessageEntity[]) {\n  // entities = entities.slice();\n  for(let i = 0; i < entities.length; ++i) {\n    const entity = entities[i];\n\n    let nextEntityIdx = -1;\n    do {\n      nextEntityIdx = entities.findIndex((e, _i) => {\n        return CAN_COMBINE_ENTITIES.has(e._) && _i !== i && e._ === entity._ && (e.offset - entity.length) === entity.offset;\n      });\n\n      if(nextEntityIdx !== -1) {\n        const nextEntity = entities[nextEntityIdx];\n        entity.length += nextEntity.length;\n        entities.splice(nextEntityIdx, 1);\n      }\n    } while(nextEntityIdx !== -1);\n  }\n  // return entities;\n}\n","import {MessageEntity} from '../../layer';\n\nexport default function sortEntities(entities: MessageEntity[]) {\n  entities.sort((a, b) => {\n    return (a.offset - b.offset) || (b.length - a.length);\n  });\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport {MessageEntity} from '../../layer';\nimport BOM from '../string/bom';\n\nexport type MarkdownType = 'bold' | 'italic' | 'underline' | 'strikethrough' |\n  'monospace' | 'link' | 'mentionName' | 'spoiler' | 'quote'/*  | 'customEmoji' */;\nexport type MarkdownTag = {\n  match: string,\n  entityName: Extract<\n    MessageEntity['_'], 'messageEntityBold' | 'messageEntityUnderline' |\n    'messageEntityItalic' | 'messageEntityCode' | 'messageEntityStrike' |\n    'messageEntityTextUrl' | 'messageEntityMentionName' | 'messageEntitySpoiler' |\n    'messageEntityBlockquote'/*  | 'messageEntityCustomEmoji' */\n  >;\n};\n\n// https://core.telegram.org/bots/api#html-style\nexport const markdownTags: {[type in MarkdownType]: MarkdownTag} = {\n  bold: {\n    match: '[style*=\"bold\"], [style*=\"font-weight: 700\"], [style*=\"font-weight: 600\"], [style*=\"font-weight:700\"], [style*=\"font-weight:600\"], b, strong',\n    entityName: 'messageEntityBold'\n  },\n  underline: {\n    match: '[style*=\"underline\"], u, ins',\n    entityName: 'messageEntityUnderline'\n  },\n  italic: {\n    match: '[style*=\"italic\"], i, em',\n    entityName: 'messageEntityItalic'\n  },\n  monospace: {\n    match: '[style*=\"monospace\"], [face*=\"monospace\"], pre',\n    entityName: 'messageEntityCode'\n  },\n  strikethrough: {\n    match: '[style*=\"line-through\"], [style*=\"strikethrough\"], strike, del, s',\n    entityName: 'messageEntityStrike'\n  },\n  link: {\n    match: 'A:not(.follow)',\n    entityName: 'messageEntityTextUrl'\n  },\n  mentionName: {\n    match: 'A.follow',\n    entityName: 'messageEntityMentionName'\n  },\n  spoiler: {\n    match: '[style*=\"spoiler\"]',\n    entityName: 'messageEntitySpoiler'\n  },\n  quote: {\n    match: '[style*=\"quote\"], .quote',\n    entityName: 'messageEntityBlockquote'\n  }\n  // customEmoji: {\n  //   match: '.custom-emoji',\n  //   entityName: 'messageEntityCustomEmoji'\n  // }\n};\n\nconst tabulationMatch = '[style*=\"table-cell\"], th, td';\n\n/* export function getDepth(child: Node, container?: Node) {\n  let depth = 0;\n\n  do {\n    if(child === container) {\n      return depth;\n    }\n\n    ++depth;\n  } while((child = child.parentNode) !== null);\n\n  return depth;\n} */\n\nconst BLOCK_TAGS = new Set([\n  'DIV',\n  'P',\n  'BR',\n  'LI',\n  'SECTION',\n  'H6',\n  'H5',\n  'H4',\n  'H3',\n  'H2',\n  'H1',\n  'TR',\n  'OL',\n  'UL',\n  'BLOCKQUOTE'\n]);\n\n// const INSERT_NEW_LINE_TAGS = new Set([\n//   'OL',\n//   'UL'\n// ]);\n\nconst BOM_REG_EXP = new RegExp(BOM, 'g');\nexport const SELECTION_SEPARATOR = '\\x01';\n\nfunction checkNodeForEntity(node: Node, value: string, entities: MessageEntity[], offset: {offset: number}) {\n  const parentElement = node.parentElement;\n\n  // let closestTag: MarkdownTag, closestElementByTag: Element, closestDepth = Infinity;\n  for(const type in markdownTags) {\n    const tag = markdownTags[type as MarkdownType];\n    const closest: HTMLElement = parentElement.closest(tag.match + ', [contenteditable=\"true\"]');\n    if(closest?.getAttribute('contenteditable') !== null) {\n      /* const depth = getDepth(closest, parentElement.closest('[contenteditable]'));\n      if(closestDepth > depth) {\n        closestDepth = depth;\n        closestTag = tag;\n        closestElementByTag = closest;\n      } */\n      continue;\n    }\n\n    let codeElement: HTMLElement;\n    if(tag.entityName === 'messageEntityCode' && (codeElement = parentElement.closest('[data-language]'))) {\n      entities.push({\n        _: 'messageEntityPre',\n        language: codeElement.dataset.language || '',\n        offset: offset.offset,\n        length: value.length\n      });\n    } else if(tag.entityName === 'messageEntityTextUrl') {\n      entities.push({\n        _: tag.entityName,\n        url: (closest as HTMLAnchorElement).href,\n        offset: offset.offset,\n        length: value.length\n      });\n    } else if(tag.entityName === 'messageEntityMentionName') {\n      entities.push({\n        _: tag.entityName,\n        offset: offset.offset,\n        length: value.length,\n        user_id: (closest as HTMLElement).dataset.follow.toUserId()\n      });\n    } else if(tag.entityName === 'messageEntityBlockquote') {\n      entities.push({\n        _: tag.entityName,\n        pFlags: {\n          collapsed: /* closest.classList.contains('can-send-collapsd') &&  */!!closest.dataset.collapsed || undefined\n        },\n        offset: offset.offset,\n        length: value.length\n      });\n    } /*  else if(tag.entityName === 'messageEntityCustomEmoji') {\n      entities.push({\n        _: tag.entityName,\n        document_id: (closest as HTMLElement).dataset.docId,\n        offset: offset.offset,\n        length: emoji.length\n      });\n    } */ else {\n      entities.push({\n        _: tag.entityName,\n        offset: offset.offset,\n        length: value.length\n      });\n    }\n  }\n}\n\nfunction isLineEmpty(line: string[]) {\n  const {length} = line;\n  if(!length) {\n    return true;\n  }\n\n  if(line[length - 1] === SELECTION_SEPARATOR && length === SELECTION_SEPARATOR.length) {\n    return true;\n  }\n\n  return false;\n}\n\nexport default function getRichElementValue(\n  node: HTMLElement,\n  lines: string[],\n  line: string[],\n  selNode?: Node,\n  selOffset?: number,\n  entities?: MessageEntity[],\n  offset: {offset: number, isInQuote?: boolean} = {offset: 0}\n) {\n  if(node.nodeType === node.TEXT_NODE) { // TEXT\n    let nodeValue = node.nodeValue;\n    // if(nodeValue[0] === BOM) {\n    nodeValue = nodeValue.replace(BOM_REG_EXP, '');\n    // }\n\n    /* const tabulation = node.parentElement?.closest(tabulationMatch + ', [contenteditable]');\n    if(tabulation?.getAttribute('contenteditable') === null) {\n      nodeValue += ' ';\n      // line.push('\\t');\n      // ++offset.offset;\n    } */\n\n    if(nodeValue) {\n      // if(offset.isInQuote && nodeValue.endsWith('\\n')) { // slice last linebreak from quote\n      //   nodeValue = nodeValue.slice(0, -1);\n      // }\n\n      if(selNode === node) {\n        line.push(nodeValue.substr(0, selOffset) + SELECTION_SEPARATOR + nodeValue.substr(selOffset));\n      } else {\n        line.push(nodeValue);\n      }\n    } else if(selNode === node) {\n      line.push(SELECTION_SEPARATOR);\n    }\n\n    if(entities && nodeValue.length && node.parentNode) {\n      checkNodeForEntity(node, nodeValue, entities, offset);\n    }\n\n    offset.offset += nodeValue.length;\n    return;\n  }\n\n  if(node.nodeType !== node.ELEMENT_NODE) { // NON-ELEMENT\n    return;\n  }\n\n  const pushLine = () => {\n    lines.push(line.join(''));\n    line.length = 0;\n    ++offset.offset;\n  };\n\n  const isSelected = selNode === node;\n  const isQuote = node.matches(markdownTags.quote.match);\n  const isBlock = BLOCK_TAGS.has(node.tagName) || isQuote;\n  if(isBlock && ((line.length && line[line.length - 1].slice(-1) !== '\\n') || node.tagName === 'BR'/*  || (BLOCK_TAGS.has(node.tagName) && lines.length) */)) {\n    pushLine();\n  } else {\n    const alt = node.dataset.stickerEmoji || (node as HTMLImageElement).alt;\n    const stickerEmoji = node.dataset.stickerEmoji;\n\n    if(alt && entities) {\n      checkNodeForEntity(node, alt, entities, offset);\n    }\n\n    if(stickerEmoji && entities) {\n      entities.push({\n        _: 'messageEntityCustomEmoji',\n        document_id: node.dataset.docId,\n        offset: offset.offset,\n        length: alt.length\n      });\n    }\n\n    if(alt) {\n      line.push(alt);\n      offset.offset += alt.length;\n    }\n  }\n\n  if(isSelected && !selOffset) {\n    line.push(SELECTION_SEPARATOR);\n  }\n\n  const isTableCell = node.matches(tabulationMatch);\n  const wasEntitiesLength = entities?.length;\n  // const wasLinesLength = lines.length;\n  let wasNodeEmpty = true;\n\n  if(isQuote) {\n    offset.isInQuote = true;\n  }\n\n  let curChild = node.firstChild as HTMLElement;\n  while(curChild) {\n    getRichElementValue(curChild, lines, line, selNode, selOffset, entities, offset);\n    curChild = curChild.nextSibling as any;\n\n    if(!isLineEmpty(line)) {\n      wasNodeEmpty = false;\n    }\n  }\n\n  if(isQuote) {\n    const lastValue = line[line.length - 1];\n    if(lastValue?.endsWith('\\n')) { // slice last linebreak from quote\n      line[line.length - 1] = lastValue.slice(0, -1);\n      offset.offset -= 1;\n    }\n\n    offset.isInQuote = false;\n  }\n\n  // can test on text with list (https://www.who.int/initiatives/sports-and-health)\n  if(wasNodeEmpty && node.textContent?.replace(/[\\r\\n]/g, '')) {\n    wasNodeEmpty = false;\n  }\n\n  if(isSelected && selOffset) {\n    line.push(SELECTION_SEPARATOR);\n  }\n\n  if(isTableCell && node.nextSibling && !isLineEmpty(line)) {\n    line.push(' ');\n    ++offset.offset;\n\n    // * combine entities such as url after adding space\n    if(wasEntitiesLength !== undefined) {\n      for(let i = wasEntitiesLength, length = entities.length; i < length; ++i) {\n        ++entities[i].length;\n      }\n    }\n  }\n\n  if(isBlock && !wasNodeEmpty) {\n    pushLine();\n  }\n\n  if(!wasNodeEmpty && node.tagName === 'P' && node.nextSibling) {\n    lines.push('');\n    ++offset.offset;\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport {MOUNT_CLASS_TO} from '../../config/debug';\nimport {MessageEntity} from '../../layer';\nimport combineSameEntities from '../../lib/richTextProcessor/combineSameEntities';\nimport sortEntities from '../../lib/richTextProcessor/sortEntities';\nimport getRichElementValue, {SELECTION_SEPARATOR} from './getRichElementValue';\n\nexport function getCaretPos(field: Node) {\n  const sel = window.getSelection();\n  let selNode: Node;\n  let selOffset: number;\n  if(sel?.rangeCount) {\n    const range = sel.getRangeAt(0);\n    const startOffset = range.startOffset;\n    if(\n      range.startContainer &&\n      range.startContainer == range.endContainer &&\n      startOffset == range.endOffset\n    ) {\n      // * if focused on img, or caret has been set via placeCaretAtEnd\n      const possibleChildrenFocusOffset = startOffset - 1;\n      const childNodes = field.childNodes;\n      if(range.startContainer === field && childNodes[possibleChildrenFocusOffset]) {\n        selNode = childNodes[possibleChildrenFocusOffset];\n        selOffset = 0;\n\n        for(let i = 0; i < range.endOffset; ++i) {\n          const node = childNodes[i];\n          const value = node.nodeValue || (node as HTMLImageElement).alt;\n\n          if(value) {\n            selOffset += value.length;\n          }\n        }\n      } else {\n        selNode = range.startContainer;\n        selOffset = startOffset;\n      }\n    }\n  }\n\n  return {node: selNode, offset: selOffset};\n}\n\nexport default function getRichValueWithCaret(\n  field: Node | HTMLElement | DocumentFragment,\n  withEntities = true,\n  withCaret = true\n) {\n  const lines: string[] = [];\n  const line: string[] = [];\n\n  const {node: selNode, offset: selOffset} = !(field instanceof DocumentFragment) && withCaret && getCaretPos(field);\n\n  const entities: MessageEntity[] = withEntities ? [] : undefined;\n  const offset = {offset: 0};\n  if(field instanceof DocumentFragment) {\n    let curChild = field.firstChild as HTMLElement;\n    while(curChild) {\n      getRichElementValue(curChild, lines, line, selNode, selOffset, entities, offset);\n      curChild = curChild.nextSibling as any;\n    }\n  } else {\n    getRichElementValue(field as HTMLElement, lines, line, selNode, selOffset, entities, offset);\n  }\n\n  if(line.length) {\n    lines.push(line.join(''));\n  }\n\n  let value = lines.join('\\n');\n  const caretPos = value.indexOf(SELECTION_SEPARATOR);\n  if(caretPos !== -1) {\n    value = value.substr(0, caretPos) + value.substr(caretPos + 1);\n  }\n  value = value.replace(/\\u00A0/g, ' ');\n\n  if(entities?.length) {\n    // ! cannot do that here because have the same check before the sending in RichTextProcessor.parseMarkdown\n    /* const entity = entities[entities.length - 1];\n    const length = value.length;\n    const trimmedLength = value.trimRight().length;\n    if(length !== trimmedLength) {\n      entity.length -= length - trimmedLength;\n    } */\n\n    combineSameEntities(entities);\n    sortEntities(entities);\n  }\n\n  return {value, entities, caretPos};\n}\n\nMOUNT_CLASS_TO.getCaretPos = getCaretPos;\nMOUNT_CLASS_TO.getRichValueWithCaret = getRichValueWithCaret;\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nexport default function isInputEmpty(element: HTMLElement, allowStartingSpace?: boolean) {\n  let value: string;\n  if(element.isContentEditable || element.tagName !== 'INPUT') {\n    if(element.querySelector('.emoji, .custom-emoji, .custom-emoji-placeholder')) {\n      return false;\n    }\n    /* const value = element.innerText;\n\n    return !value.trim() && !serializeNodes(Array.from(element.childNodes)).trim(); */\n    // return !getRichValueWithCaret(element, false, false).value.trim();\n    value = element.textContent;\n  } else {\n    value = (element as HTMLInputElement).value;\n  }\n\n  if(!allowStartingSpace) {\n    return !value.trim();\n  }\n\n  return !value;\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport clamp from '../number/clamp';\nimport findUpAsChild from './findUpAsChild';\nimport whichChild from './whichChild';\n\nexport default function compareNodes(node1: ChildNode, node1Offset: number, node2: ChildNode, node2Offset: number) {\n  let diff: number;\n  if(node1 === node2) {\n    diff = node1Offset - node2Offset;\n  } else if(node1.parentElement === node2.parentElement) {\n    diff = whichChild(node1, true) - whichChild(node2, true);\n  } else {\n    const parents: HTMLElement[] = [];\n    let parentElement = node1.parentElement;\n    do {\n      parents.push(parentElement);\n    } while(parentElement = parentElement.parentElement);\n\n    parentElement = node2.parentElement;\n    do {\n      if(parents.includes(parentElement)) {\n        break;\n      }\n    } while(parentElement = parentElement.parentElement);\n\n    const commonAncestorContainer = parentElement;\n    // const range = document.createRange();\n    // range.setStart(node1, 0);\n    // range.setEnd(node2, node2.textContent.length);\n    // const {commonAncestorContainer} = range;\n    node1 = findUpAsChild(node1 as HTMLElement, commonAncestorContainer as HTMLElement);\n    node2 = findUpAsChild(node2 as HTMLElement, commonAncestorContainer as HTMLElement);\n    diff = whichChild(node1, true) - whichChild(node2, true);\n  }\n\n  return clamp(diff, -1, 1);\n}\n\n(window as any).compareNodes = compareNodes;\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport {IS_FIREFOX} from '../../environment/userAgent';\nimport {logger} from '../../lib/logger';\nimport {isCustomFillerNeededBySiblingNode} from '../../lib/richTextProcessor/wrapRichText';\nimport ListenerSetter from '../listenerSetter';\nimport BOM from '../string/bom';\nimport compareNodes from './compareNodes';\nimport getCaretPosNew from './getCaretPosNew';\nimport placeCaretAtEnd from './placeCaretAtEnd';\nimport whichChild from './whichChild';\n\nconst NOT_ONLY_BOMS_REG_EXP = new RegExp(`[^${BOM}]`);\n\nexport const USING_BOMS = false;\n\nexport default class RichInputHandler {\n  private static INSTANCE: RichInputHandler;\n\n  private listenerSetter: ListenerSetter;\n\n  private lastNode: Node;\n  private lastOffset: number;\n  private savedRanges: WeakMap<HTMLElement, Range>;\n\n  private log: ReturnType<typeof logger>;\n\n  private inputCaptureCallbacks: Function[];\n\n  constructor() {\n    this.log = logger('RICH-INPUT');\n    this.listenerSetter = new ListenerSetter();\n    this.savedRanges = new WeakMap();\n\n    this.listenerSetter.add(document)('selectionchange', this.saveSelectionOnChange);\n    if(USING_BOMS) {\n      this.listenerSetter.add(document)('focusout', this.onFocusOut);\n      this.listenerSetter.add(document)('selectionchange', this.onSelectionChange);\n      this.listenerSetter.add(document)('beforeinput', this.onBeforeInput);\n      this.listenerSetter.add(document)('keydown', this.onKeyDown, {capture: true});\n\n      if(IS_FIREFOX) {\n        this.inputCaptureCallbacks = [];\n        this.listenerSetter.add(document)('input', () => {\n          this.inputCaptureCallbacks.forEach((callback) => callback());\n          this.inputCaptureCallbacks.length = 0;\n        }, {capture: true});\n      }\n    }\n  }\n\n  private get input() {\n    const selection = document.getSelection();\n    const {anchorNode: node} = selection;\n    if(!node) return;\n    return ((node as HTMLElement).closest ? node as HTMLElement : node.parentElement).closest<HTMLElement>('[contenteditable=\"true\"]');\n  }\n\n  private saveRangeForElement(element: HTMLElement) {\n    if(element && (element.isContentEditable || element.tagName === 'INPUT')) {\n      const selection = document.getSelection();\n      if(selection.rangeCount) {\n        this.savedRanges.set(element as HTMLElement, document.getSelection().getRangeAt(0));\n      }\n    }\n  }\n\n  private saveSelectionOnChange = (e: Event) => {\n    const element = document.activeElement as HTMLElement; // e.target as HTMLElement;\n    this.saveRangeForElement(element);\n  };\n\n  private onFocusOut = (e: FocusEvent) => {\n    this.lastNode = this.lastOffset = undefined;\n  };\n\n  private findPreviousSmthIndex(input: HTMLElement, node: ChildNode, something?: NodeListOf<Element>) {\n    // node = this.getFiller(node);\n    // const childNodes = Array.from(node.parentElement.childNodes);\n    // fillerIndex = childNodes.indexOf(node);\n    // let smthIndex = -1;\n    // for(let i = fillerIndex; i >= 0; --i) {\n    //   const node = childNodes[i];\n    //   if((node as HTMLElement)?.classList?.contains('input-something')) {\n    //     smthIndex = i;\n    //     break;\n    //   }\n    // }\n    // return smthIndex;\n\n    const elements = Array.from(something ?? input.querySelectorAll('.input-something'));\n    const index = elements.findIndex((element) => compareNodes(element, 0, node, 0) >= 0);\n    return index === -1 ? elements.length - 1 : Math.max(0, index - 1);\n  }\n\n  private superMove(\n    input: HTMLElement,\n    caret: ReturnType<RichInputHandler['getCaretPosN']>,\n    toLeft: boolean,\n    fromSelectionChange: boolean\n  ) {\n    const {node, offset, move} = caret;\n    const something = input.querySelectorAll('.input-something');\n    const smthIndex = this.findPreviousSmthIndex(input, node, something);\n    const r = document.createRange();\n    r[toLeft ? 'setEnd' : 'setStart'](node, offset);\n\n    if(fromSelectionChange) {\n      move(toLeft);\n    }\n\n    const c = this.getCaretPosN();\n    if(c.node?.nodeValue === BOM && (!fromSelectionChange || node === this.lastNode)) {\n      const idx = this.findPreviousSmthIndex(input, c.node, something);\n\n      let moved = !fromSelectionChange;\n\n      do {\n        const c = this.getCaretPosN();\n        const idxidx = this.findPreviousSmthIndex(input, c.node, something);\n        r[toLeft ? 'setStart' : 'setEnd'](c.node, c.offset);\n        const rangeString = r.toString();\n        const onlyBOMs = !NOT_ONLY_BOMS_REG_EXP.test(rangeString);\n        this.log('test cursor', rangeString, onlyBOMs, idx, idxidx);\n        if(\n          onlyBOMs &&\n          c.node?.nodeValue === BOM &&\n          idxidx === idx &&\n          // (idxidx > 1 || c.offset) &&\n          // (idxidx < (getFiller(c.node).parentElement.childNodes.length - 2) || c.offset < BOM.length)\n          (idxidx || c.offset) &&\n          (idxidx < (something.length - 1) || c.offset < BOM.length)\n        ) {\n          move(toLeft);\n          moved = true;\n        } else if(!moved) {\n          break;\n        } else {\n          if((!this.getFiller(node as HTMLElement).classList.contains('input-filler-text') && idx !== smthIndex) || c.offset === BOM.length) {\n            move(!toLeft);\n          }\n\n          break;\n        }\n      } while(true);\n    }\n  }\n\n  private onSelectionChange = (e: Event) => {\n    const {input} = this;\n    if(!input) {\n      this.setSelectionClassName(document.getSelection());\n      return;\n    }\n\n    // return;\n\n    // this.log('selectionchange', document.getSelection(), document.getSelection().rangeCount && document.getSelection().getRangeAt(0), getCaretPosN());\n    // let {node, offset} = getCaretPos(this.messageInput);\n\n    let caret = this.getCaretPosN();\n    do {\n      const {node, offset, selection, move} = caret;\n\n      const nodeValue = node?.nodeValue;\n      // if(!nodeValue?.includes(BOM)) {\n      if(nodeValue !== BOM || !this.lastNode) {\n        break;\n      }\n\n      // node = getFiller(node);\n\n      // const childIndex = whichChild(getFiller(node), true);\n      // let toLeft: boolean;\n      // // if(node === lastNode) toLeft = lastOffset >= offset;\n      // if(node === lastNode) toLeft = lastOffset > offset;\n      // else {\n      //   // toLeft = whichChild(getFiller(lastNode)) > childIndex;\n      //   toLeft = (lastNode.nodeValue === BOM ? whichChild(getFiller(lastNode), true) : whichChild(findUpAsChild(lastNode as any, getFiller(node).parentElement), true)) > childIndex;\n      // }\n\n      const toLeft = compareNodes(node, offset, this.lastNode as ChildNode, this.lastOffset) < 0;\n\n      // const childNodes = Array.from(node.parentElement.childNodes);\n      // if(toLeft) {\n      //   for(let i = childIndex; i >= 0; --i) {\n      //     const sibling = childNodes[i];\n      //     const {textContent} = sibling;\n      //     for()\n      //   }\n      // }\n\n      // {\n      //   if(toLeft === undefined) {\n      //     return;\n      //   }\n\n      //   const selection = window.getSelection();\n      //   selection.modify(selection.isCollapsed ? 'move' : 'extend', toLeft ? 'backward' : 'forward', 'character');\n      //   return;\n      // }\n\n      // const parent = getFiller(node);\n      if(toLeft !== undefined) {\n        // let newNode = toLeft ? parent.previousSibling : parent.nextSibling;\n        if(selection.isCollapsed) {\n          this.superMove(input, caret, toLeft, true);\n\n          // if(offset === BOM.length) {\n          //   newNode = toLeft ? newNode.nextSibling.nextSibling : parent.previousSibling.previousSibling;\n          // }\n\n          // setCaretAt(newNode);\n        } else {\n          selection.modify(selection.isCollapsed ? 'move' : 'extend', toLeft ? 'backward' : 'forward', 'character');\n          // const range = selection.getRangeAt(0);\n\n          // if(toLeft) {\n          //   newNode = parent.previousSibling.previousSibling.firstChild;\n          //   const value = newNode.nodeValue;\n          //   range.setStart(newNode, value?.length);\n          // } else {\n          //   newNode = parent.nextSibling.nextSibling.firstChild;\n          //   range.setEnd(newNode, 0);\n          // }\n        }\n      }\n\n      this.log('selectionchange',\n        node,\n        offset,\n        this.lastNode,\n        this.lastOffset,\n        node === this.lastNode,\n        whichChild(this.getFiller(node)),\n        whichChild(this.getFiller(this.lastNode)),\n        toLeft,\n        selection,\n        document.getSelection(),\n        document.getSelection().getRangeAt(0),\n        node?.parentNode,\n        this.lastNode?.parentNode\n      );\n\n      caret = this.getCaretPosN();\n      this.lastNode = node;\n      this.lastOffset = offset;\n\n      break;\n\n      // if(findPreviousSmthIndex(caret.node) !== smthIndex) {\n      //   break;\n      // }\n    } while(true);\n\n    this.lastNode = this.lastOffset = undefined;\n\n    // if(offset === BOM.length) {\n    //   setCaretAt(parent);\n    // } else {\n    //   setCaretAt(parent.nextSibling);\n    // }\n\n    this.setSelectionClassName(caret.selection, input);\n  };\n\n  public restoreSavedRange(input: HTMLElement) {\n    const range = this.getSavedRange(input);\n    if(!range) {\n      return false;\n    }\n\n    const selection = window.getSelection();\n    selection.removeAllRanges();\n    selection.addRange(range);\n\n    return true;\n  }\n\n  public getSavedRange(input: HTMLElement) {\n    return this.savedRanges.get(input);\n  }\n\n  public makeFocused(input: HTMLElement) {\n    if(document.activeElement !== input && !this.restoreSavedRange(input)) {\n      placeCaretAtEnd(input, false, false);\n    }\n  }\n\n  private fixInsertedLineBreaks(input: HTMLElement) {\n    input.querySelectorAll('br').forEach((br) => {\n      br.classList.add('br-not-br');\n    });\n  }\n\n  private fixBuggedCaret() {\n    const selection = document.getSelection();\n    const range = selection.getRangeAt(0);\n    selection.removeAllRanges();\n    selection.addRange(range);\n  }\n\n  public onBeforeInput = (e: Pick<InputEvent, 'inputType'>) => {\n    const {input, log} = this;\n    if(!input) {\n      return;\n    }\n\n    const addInputCallback = this.addInputCallback.bind(this, input);\n\n    const caretPos = this.getCaretPosN();\n    let {node, offset, selection, move} = caretPos;\n    log('beforeinput', e, node, offset, selection, caretPos);\n    this.lastNode = this.lastOffset = undefined;\n\n    if(e.inputType.startsWith('delete')) { // delete current BOM\n      addInputCallback(() => {\n        this.processEmptiedFillers(input);\n        this.removeExtraBOMs(input);\n        this.fixInsertedLineBreaks(input);\n      });\n\n      if(node?.nodeValue === BOM && selection.isCollapsed && e.inputType.includes('deleteContent')) {\n        const toLeft = e.inputType.includes('Backward');\n        const moveFirst = (offset === BOM.length && toLeft) || (!offset && !toLeft);\n        this.superMove(input, caretPos, toLeft, moveFirst);\n        // if((offset === BOM.length && toLeft) || (!offset && !toLeft)) {\n        //   move(toLeft);\n        // }\n\n        // addInputCallback(() => {\n        //   removePossibleBOMSiblingsByNode(getFiller(node));\n        // });\n\n        // if(node.parentNode.childNodes.length === 1) {\n        //   (node.parentNode as HTMLElement).remove();\n        //   move(e.inputType.includes('Backward') ? false : true);\n        // } else {\n        //   move(e.inputType.includes('Backward') ? true : false);\n        //   addInputCallback(() => {\n        //     move(e.inputType.includes('Backward') ? false : true);\n        //   });\n        // }\n\n        // for(let i = 0, length = BOM.length + (direction === 'backward' ? offset : BOM.length - offset); i < length; ++i) {\n        //   selection.modify('extend', direction, 'character');\n        // }\n\n        // selection.modify('extend', direction, 'character');\n        // selection.modify('extend', direction, 'character');\n\n        // selection.deleteFromDocument();\n        // e.preventDefault();\n      } else {\n        // const filler = getFiller(node);\n        // if(filler?.classList?.contains('input-filler-text')) {\n        //   const {previousSibling, nextSibling} = filler;\n        //   addInputCallback(() => {\n        //     if(!filler.isConnected) {\n        //       removePossibleBOMSiblings(previousSibling, nextSibling);\n        //     }\n        //     // removeExtraBOMs();\n        //     // processEmptiedFillers();\n        //   });\n        // }\n        // addInputCallback(() => {\n        //   this.fixInsertedLineBreaks(input);\n        // });\n      }\n    } else if(e.inputType.startsWith('insert')) { // clear current BOM\n      if((node as HTMLElement)?.classList?.contains('input-something')/*  || (node.textContent === BOM && offset === BOM.length) */) {\n        node = node.previousSibling.firstChild;\n        const range = selection.getRangeAt(0);\n        range.setStart(node, 0);\n        range.setEnd(node, 0);\n        range.collapse(true);\n        // selection.modify('move', 'backward', 'character');\n\n        const c = this.getCaretPosN();\n        node = c.node;\n        selection = c.selection;\n        offset = c.offset;\n      }\n      if(node && node.textContent === BOM && offset === BOM.length) {\n        // const range = selection.getRangeAt(0);\n        // range.setStart(node, 0);\n        // range.setEnd(node, 0);\n        // range.collapse(true);\n        selection.modify('move', 'backward', 'character');\n\n        const c = this.getCaretPosN();\n        node = c.node;\n        selection = c.selection;\n        offset = c.offset;\n      }\n      // if(node && node.textContent === BOM && offset === 0) {\n      //   selection.modify('move', 'forward', 'character');\n      //   offset = BOM.length;\n      // }\n\n      if(e.inputType === 'insertLineBreak' || true) {\n        // const appendix = 'X';\n        // const textNode = document.createTextNode(appendix);\n        // if(node.parentElement !== this.messageInput) node.parentElement.after(textNode);\n        // else node.after(textNode);\n        // selection.modify('move', 'forward', 'character');\n        // selection.modify('move', 'forward', 'character');\n        // addInputCallback(() => {\n        //   textNode.remove();\n        // });\n\n        /* if(node?.nodeValue === BOM) */ {\n          // const parent = node.parentElement;\n          // parent.contentEditable = 'false';\n          // addInputCallback(() => {\n          //   parent.contentEditable = 'inherit';\n          // });\n          // node.parentElement.remove();\n\n          // const textNode = document.createTextNode(appendix);\n          // if(node.parentElement !== this.messageInput) node.parentElement.after(textNode);\n          // else node.after(textNode);\n          // // selection.modify('move', 'forward', 'character');\n          // // selection.modify('move', 'forward', 'character');\n          // addInputCallback(() => {\n          //   textNode.remove();\n          // });\n\n          // fix case when focused somehow on span instead of text node\n          if(node && node.nodeType === node.ELEMENT_NODE) {\n            node = node.firstChild;\n            log.warn('fixing focus on span');\n          }\n\n          const isBOM = node?.nodeValue === BOM;\n          log('inserting line break', isBOM, node, `\"${node?.nodeValue}\"`, node?.parentElement ? Array.from(node.parentElement.childNodes).slice() : []);\n          if(isBOM) {\n            // (node as ChildNode).replaceWith(this.messageInput.querySelector('.lol'));\n\n            const parentElement = node.parentElement;\n            parentElement.classList.replace('input-filler', 'input-filler-text');\n            const childNodesLength = parentElement.childNodes.length;\n            addInputCallback(() => {\n              const newChildNodesLength = parentElement.childNodes.length;\n              if(newChildNodesLength > 1/*  && newChildNodesLength !== childNodesLength */) {\n                log('inserting line break, remove');\n                node = Array.from(parentElement.childNodes).find((node) => node.nodeValue === BOM);\n                (parentElement as any).t = node;\n                // node?.remove();\n\n                // const n = parentElement.firstChild;\n                // const range = selection.getRangeAt(0);\n                // range.setStart(n, n.nodeValue.length);\n                // range.setEnd(n, n.nodeValue.length);\n              } else if(node.nodeValue !== BOM) {\n                log('inserting line break, deleteData');\n                (node as CharacterData).deleteData(node.nodeValue.indexOf(BOM), BOM.length);\n                // node = document.createTextNode(BOM);\n              }\n\n              this.fixInsertedLineBreaks(input);\n              // (parentElement as any).t = node;\n              // node.remove();\n            });\n            // addInputCallback(() => {\n            //   node.parentElement.classList.replace('input-filler', 'input-filler3');\n            //   const s = document.createElement('span');\n            //   s.style.display = 'none';\n            //   node.replaceWith(s);\n            //   s.prepend(node);\n            // });\n          } else if(e.inputType === 'insertLineBreak') {\n            addInputCallback(() => {\n              this.fixInsertedLineBreaks(input);\n            });\n            // const range = selection.getRangeAt(0);\n            // this.messageInput.querySelectorAll<HTMLElement>('.input-something').forEach((el) => {\n            //   el.contentEditable = 'inherit';\n            // });\n\n            // addInputCallback(() => {\n            //   this.messageInput.querySelectorAll<HTMLElement>('.input-something').forEach((el) => {\n            //     el.contentEditable = 'false';\n            //   });\n\n            //   selection.removeAllRanges();\n            //   selection.addRange(range);\n            // }, false);\n          }/*  else if(node &&\n            node.nodeType === node.TEXT_NODE &&\n            node.nodeValue.length === offset) {\n\n          } */\n\n          // if(e.inputType === 'insertLineBreak') {\n          //   e.preventDefault();\n          //   document.execCommand('insertHTML', false, '<span class=\"lol\">\\n</span>');\n\n          //   this.messageInputField.simulateInputEvent();\n          // }\n\n          // node.parentElement.replaceWith(node);\n          // selection.removeAllRanges();\n          // const range = new Range();\n          // range.setStart(node, 0);\n          // range.setEnd(node, node.nodeValue.length);\n          // selection.addRange(range);\n          // node.parentElement.classList.remove('input-filler');\n          // node.parentElement\n        }\n\n        // document.execCommand('insertHTML', false, '\\n');\n        // e.preventDefault();\n        // (node as CharacterData).deleteData(node.nodeValue.indexOf(BOM), BOM.length);\n        // if(node?.nodeValue === BOM) {\n        //   addInputCallback(() => {\n        //     node.remove();\n        //   });\n        // }\n        // this.messageInputField.simulateInputEvent();\n\n        // this.messageInput.querySelectorAll<HTMLElement>('.input-something').forEach((el) => {\n        //   el.contentEditable = 'inherit';\n        // });\n        // addInputCallback(() => {\n        //   this.messageInput.querySelectorAll<HTMLElement>('.input-something').forEach((el) => {\n        //     el.contentEditable = 'false';\n        //   });\n        // });\n        return;\n      }\n\n      if(node?.nodeValue === BOM) {\n        // node.nodeValue = ''; // ! will move cursor forward\n        // addInputCallback(() => {\n        //   (node as CharacterData).deleteData(node.nodeValue.indexOf(BOM), BOM.length);\n        // });\n\n        if(e.inputType === 'insertLineBreak') {\n          if(offset === BOM.length) {\n            selection.modify('move', 'backward', 'character');\n          }\n\n          // if(offset !== BOM.length) {\n          //   selection.modify('move', 'forward', 'character');\n          // }\n\n          addInputCallback(() => {\n            node.remove();\n            // (node as CharacterData).deleteData(node.nodeValue.indexOf(BOM), BOM.length);\n            // selection.modify('move', 'forward', 'character');\n\n            setTimeout(() => {\n              selection.modify('move', 'forward', 'character');\n            }, 0);\n          });\n        }\n\n        // node.parentElement.replaceWith(node);\n\n        // node.parentElement.replaceWith(node);\n        if(e.inputType === 'insertLineBreak') {\n          // const previousParentSibling = node.parentNode.previousSibling;\n          // addInputCallback(() => {\n          //   if(previousParentSibling.nextSibling.nodeValue === '\\n') {\n          //     previousParentSibling.nextSibling.remove();\n\n          //     setTimeout(() => {\n          //       // selection.modify('move', 'forward', 'character');\n          //       // selection.modify('move', 'forward', 'character');\n          //     }, 0);\n          //   } else {\n          //     previousParentSibling.nextSibling.nodeValue = previousParentSibling.nextSibling.nodeValue.replace('\\n\\n', '\\n');\n          //   }\n          // });\n        } else {\n          // if(node.parentElement !== this.messageInput) {\n          //   node.parentElement.replaceWith(node);\n          // }\n\n          // setTimeout(() => {\n          //   this.log(JSON.stringify(node.parentElement.innerHTML));\n          //   node.nodeValue = node.nodeValue.replace(BOM, '');\n          //   // (node as CharacterData).deleteData(node.nodeValue.indexOf(BOM), BOM.length);\n          //   this.log(JSON.stringify(node.parentElement.innerHTML));\n          // }, 1000);\n\n          addInputCallback(() => {\n            (node as CharacterData).deleteData(node.nodeValue.indexOf(BOM), BOM.length);\n            if(!node.nodeValue) {\n              node.remove();\n            }\n\n            // selection.modify('move', 'forward', 'character');\n          });\n        }\n\n        if(selection.isCollapsed && false) {\n          node.parentElement.replaceWith(node);\n          // const textNode = document.createTextNode(BOM);\n          // (node.parentNode as any as ChildNode).after(textNode);\n          // setCaretAt(textNode.nextSibling);\n          // selection.modify('move', 'forward', 'character');\n          node.remove();\n          // (node as CharacterData).deleteData(node.nodeValue.indexOf(BOM), BOM.length);\n          // selection.modify('move', 'forward', 'character');\n          // selection.collapseToEnd();\n\n          // addInputCallback(() => {\n          //   (textNode as CharacterData).deleteData(textNode.nodeValue.indexOf(BOM), BOM.length);\n          //   node.parentElement.remove();\n          // });\n        }\n      } else if(e.inputType === 'insertLineBreak' &&\n        node &&\n        node.nodeType === node.TEXT_NODE &&\n        node.nodeValue.length === offset) {\n        log('inserting line break');\n        // const appendix = '\\x01';\n\n        input.querySelectorAll<HTMLElement>('.input-something').forEach((el) => {\n          el.contentEditable = 'inherit';\n        });\n        addInputCallback(() => {\n          input.querySelectorAll<HTMLElement>('.input-something').forEach((el) => {\n            el.contentEditable = 'false';\n          });\n        });\n\n        // const textNode = document.createTextNode(appendix);\n        // if(node.parentElement !== this.messageInput) node.parentElement.after(textNode);\n        // else node.after(textNode);\n        // // selection.modify('move', 'forward', 'character');\n        // addInputCallback(() => {\n        //   textNode.remove();\n        // });\n\n        // const offset = node.nodeValue.length;\n        // (node as CharacterData).insertData(offset, appendix);\n        // addInputCallback(() => {\n        //   selection.modify('move', 'forward', 'character');\n        //   (node as CharacterData).deleteData(node.nodeValue.indexOf(appendix), appendix.length);\n        //   if(!node.nodeValue) {\n        //     node.remove();\n        //   }\n        // });\n      }\n    } else if(e.inputType === 'historyUndo') { // have to remove extra BOMs\n      addInputCallback(() => {\n        this.processFilledFillers(input);\n        this.processEmptiedFillers(input);\n        this.removeExtraBOMs(input);\n        this.removeEmptyTextNodes(input);\n\n        // ! lol what, caret will be at the wrong position, have to set it to the same\n        this.fixBuggedCaret();\n\n        // lol\n        // this.messageInput.querySelectorAll('.has-text').forEach((el) => {\n        //   if(el.textContent === BOM) {\n        //     el.firstElementChild.replaceWith(el.firstElementChild.firstChild);\n        //     el.classList.replace('input-filler3', 'input-filler');\n        //   }\n        // });\n      });\n    } else if(e.inputType === 'historyRedo') {\n      // if(node?.nodeValue === BOM && offset === BOM.length) {\n      //   selection.modify('move', 'backward', 'character');\n      // }\n\n      addInputCallback(() => {\n        this.processFilledFillers(input);\n        this.processEmptiedFillers(input);\n\n        // fix contenteditable attribute\n        input.querySelectorAll<HTMLElement>('.input-something:not([contenteditable])').forEach((el) => {\n          el.contentEditable = 'false';\n        });\n\n        this.removeExtraBOMs(input);\n\n        // ! lol what, caret will be at the wrong position, have to set it to the same\n        this.fixBuggedCaret();\n      });\n    }\n  };\n\n  private onKeyDown = (e: KeyboardEvent) => {\n    const key = e.key;\n\n    // // have to ignore line up and down\n    if(key === 'ArrowDown' || key === 'ArrowUp') {\n      this.lastNode = this.lastOffset = undefined;\n    } else {\n      const {node, offset} = this.getCaretPosN();\n      this.lastNode = node/* getFiller(node) */, this.lastOffset = offset;\n      if(this.lastNode === this.input) {\n        this.lastNode = this.lastOffset = undefined;\n      }\n    }\n\n    this.log('keydown', this.lastNode, this.lastNode?.parentNode, this.lastOffset, this.getCaretPosN(), e);\n  };\n\n  private addInputCallback(input: HTMLElement, callback: () => void, capture = true) {\n    const newCallback = () => {\n      this.log('input modify callback');\n      callback();\n    };\n\n    if(capture && IS_FIREFOX) this.inputCaptureCallbacks.push(newCallback);\n    else this.listenerSetter.add(input)('input', newCallback, {once: true, capture});\n  }\n\n  public removeExtraBOMs(input: HTMLElement) {\n    const c = (sibling: ChildNode) => {\n      return (sibling as HTMLElement)?.classList?.contains('input-something');\n    };\n\n    input.querySelectorAll('.input-filler').forEach((el) => {\n      const {previousSibling, nextSibling} = el;\n      let needed = false;\n\n      // if(!(previousSibling as HTMLElement)?.classList?.contains('input-filler') && isCustomFillerNeededBySiblingNode(previousSibling)) {\n      if(!(nextSibling as HTMLElement)?.classList?.contains('input-filler') && isCustomFillerNeededBySiblingNode(nextSibling)) {\n        needed = c(previousSibling) || c(nextSibling);\n      }\n\n      if(!needed) {\n        this.log.warn('removing empty bom node', el);\n        el.remove();\n      }\n    });\n  }\n\n  private getFiller(node: Node) {\n    return node && node.nodeType === node.TEXT_NODE && node.parentElement !== this.input ? node.parentElement : node as HTMLElement;\n  }\n\n  private getCaretPosN() {\n    const ret = getCaretPosNew(this.input);\n    // const {node} = ret;\n    // if((node as HTMLElement)?.classList?.contains('input-something')) {\n    //   ret.node = node.previousSibling;\n    //   ret.offset = ret.node.textContent.length;\n    // }\n\n    return {...ret, move: this.move.bind(this, ret.selection)};\n  }\n\n  private removeEmptyTextNodes(input: HTMLElement) {\n    const {log} = this;\n    // let i = -1;\n    // remove empty text nodes\n    const treeWalker = document.createTreeWalker(\n      input,\n      NodeFilter.SHOW_TEXT,\n      {acceptNode: (node) => node.parentElement === input && !node.nodeValue/*  && !++i */ ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT}\n    );\n\n    let textNode: Text;\n    while(textNode = treeWalker.nextNode() as Text) {\n      log.warn('removing empty text node', textNode);\n      textNode.remove();\n    }\n  }\n\n  private removePossibleBOMSiblings(previousSibling: ChildNode, nextSibling: ChildNode) {\n    [previousSibling, nextSibling].forEach((sibling) => {\n      if((sibling as HTMLElement)?.classList?.contains('input-filler')) {\n        sibling.remove();\n      }\n    });\n  }\n\n  private removePossibleBOMSiblingsByNode(node: ChildNode) {\n    const {previousSibling, nextSibling} = node;\n    this.removePossibleBOMSiblings(previousSibling, nextSibling);\n  };\n\n  private processEmptiedFillers(input: HTMLElement) {\n    input.querySelectorAll<HTMLElement>('.input-filler-text').forEach((el) => {\n      this.removeExtraBOMs(el);\n\n      let cleanSiblings = true;\n      if(!el.textContent) {\n        el.classList.replace('input-filler-text', 'input-filler');\n\n        const textNode = Array.from(el.childNodes).find((node) => node.nodeType === node.TEXT_NODE);\n        if(textNode) {\n          (textNode as CharacterData).insertData(0, BOM);\n        } else if(((el as any).t as ChildNode)?.nodeValue) {\n          el.append((el as any).t);\n        } else {\n          el.append(document.createTextNode(BOM));\n        }\n      } else if(!NOT_ONLY_BOMS_REG_EXP.test(el.textContent) && !el.querySelector('.input-something')) {\n        el.classList.replace('input-filler-text', 'input-filler');\n      } else {\n        cleanSiblings = false;\n      }\n\n      if(cleanSiblings) {\n        this.removePossibleBOMSiblingsByNode(el);\n      }\n    });\n  }\n\n  private processFilledFillers(input: HTMLElement) {\n    // remove the BOM when changing to text\n    input.querySelectorAll('.input-filler').forEach((el) => {\n      if(el.textContent !== BOM) {\n        el.classList.replace('input-filler', 'input-filler-text');\n        const t = (el as any).t as ChildNode;\n        const bomNode = Array.from(el.childNodes).find((node) => node.nodeType === node.TEXT_NODE && node.nodeValue.includes(BOM));\n        if(bomNode && !t?.nodeValue) {\n          const idx = bomNode.nodeValue.indexOf(BOM);\n          if(idx !== -1) {\n            (bomNode as CharacterData).deleteData(idx, BOM.length);\n          }\n        }\n\n        // t?.remove();\n      }\n    });\n  }\n\n  private setSelectionClassName(selection: Selection, input?: HTMLElement) {\n    // Array.from(this.messageInput.querySelectorAll('.selection')).forEach((element) => {\n    //   element.classList.remove('selection');\n    // });\n\n    if(selection.rangeCount) {\n      const range = selection.getRangeAt(0);\n\n      if(input) {\n        Array.from(input.querySelectorAll('.input-selectable')).forEach((element) => {\n          element.classList.toggle('selection', !range.collapsed && range.intersectsNode(element));\n        });\n      } else {\n        Array.from(document.querySelectorAll('.input-selectable.selection')).forEach((element) => element.classList.remove('selection'));\n      }\n    }\n  }\n\n  private move(selection: Selection, left: boolean) {\n    const {focusNode: focusNodeBefore, focusOffset: focusOffsetBefore} = selection;\n    selection.modify('extend', left ? 'backward' : 'forward', 'character');\n    // if(offset === nodeValue.length) {\n    //   selection.modify('extend', !left ? 'backward' : 'forward', 'character');\n    // }\n    if(left) selection.collapseToStart();\n    else selection.collapseToEnd();\n    const {focusNode: focusNodeAfter, focusOffset: focusOffsetAfter} = selection;\n    this.log(\n      'moving cursor',\n      left,\n      focusNodeBefore,\n      focusNodeBefore.nodeType === focusNodeBefore.ELEMENT_NODE ? focusNodeBefore : focusNodeBefore.parentElement,\n      focusOffsetBefore,\n      focusNodeAfter,\n      focusNodeAfter.nodeType === focusNodeAfter.ELEMENT_NODE ? focusNodeAfter : focusNodeAfter.parentElement,\n      focusOffsetAfter\n    );\n  }\n\n  public prepareApplyingMarkdown() {\n    const {input} = this;\n\n    // do not wrap fillers into spans\n    const fillers = input.querySelectorAll<HTMLElement>('.input-filler');\n    // fillers.forEach((el) => {\n    //   el.contentEditable = 'false';\n    // });\n\n    const smths = input.querySelectorAll<HTMLElement>('.input-something');\n    smths.forEach((el) => {\n      el.contentEditable = 'inherit';\n    });\n\n    return () => {\n      fillers.forEach((el) => {\n        el.contentEditable = 'inherit';\n      });\n\n      smths.forEach((el) => {\n        el.contentEditable = 'false';\n      });\n\n      this.removeExtraBOMs(input);\n    };\n  }\n\n  public static getInstance() {\n    return this.INSTANCE ??= new RichInputHandler();\n  }\n}\n","// https://stackoverflow.com/a/6150060\nexport default function selectElementContents(el: HTMLElement) {\n  const range = document.createRange();\n  range.selectNodeContents(el);\n  const sel = window.getSelection();\n  sel.removeAllRanges();\n  sel.addRange(range);\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport {PASS_CONFLICTING_ENTITIES, PASS_SINGLE_CONFLICTING_ENTITIES} from '.';\nimport {MessageEntity} from '../../layer';\n\nconst SINGLE_ENTITIES: Set<MessageEntity['_']> = new Set(['messageEntityPre', 'messageEntityCode']);\n\nexport default function findConflictingEntity(currentEntities: MessageEntity[], newEntity: MessageEntity) {\n  let singleStart = -1, singleEnd = -1;\n  return currentEntities.find((currentEntity) => {\n    const {offset, length} = currentEntity;\n    if(SINGLE_ENTITIES.has(currentEntity._)) {\n      singleStart = offset;\n      singleEnd = singleStart + length;\n    }\n\n    if(singleStart !== -1) {\n      if(\n        newEntity.offset >= singleStart &&\n        newEntity.offset < singleEnd &&\n        !PASS_SINGLE_CONFLICTING_ENTITIES.has(newEntity._)\n      ) {\n        return true;\n      }\n    }\n\n    const isConflictingTypes = newEntity._ === currentEntity._ ||\n      (!PASS_CONFLICTING_ENTITIES.has(newEntity._) && !PASS_CONFLICTING_ENTITIES.has(currentEntity._));\n\n    if(!isConflictingTypes) {\n      return false;\n    }\n\n    const isConflictingOffset = newEntity.offset >= offset &&\n      (newEntity.length + newEntity.offset) <= (length + offset);\n\n    return isConflictingOffset;\n  });\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport {MessageEntity} from '../../layer';\nimport findConflictingEntity from './findConflictingEntity';\nimport sortEntities from './sortEntities';\n\nexport default function mergeEntities(currentEntities: MessageEntity[], newEntities: MessageEntity[]) {\n  currentEntities = currentEntities.slice();\n  const filtered = newEntities.filter((e) => {\n    return !findConflictingEntity(currentEntities, e);\n  });\n\n  currentEntities.push(...filtered);\n  sortEntities(currentEntities);\n  // currentEntities.sort((a, b) => a.offset - b.offset);\n  // currentEntities.sort((a, b) => (a.offset - b.offset) || (a._ === 'messageEntityCaret' && -1));\n\n  // * fix splitted emoji. messageEntityTextUrl can split the emoji if starts before its end (e.g. on fe0f)\n  // * have to fix even if emoji supported since it's being wrapped in span\n  // if(!IS_EMOJI_SUPPORTED) {\n  for(let i = 0; i < currentEntities.length; ++i) {\n    let entity = currentEntities[i];\n    if(entity._ === 'messageEntityEmoji') {\n      const nextEntity = currentEntities[i + 1];\n      if(nextEntity /* && nextEntity._ !== 'messageEntityCaret' */ && nextEntity.offset < (entity.offset + entity.length)) {\n        entity = currentEntities[i] = {...entity};\n        entity.length = nextEntity.offset - entity.offset;\n      }\n    }\n  }\n  // }\n\n  return currentEntities;\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type {AnimationItemGroup} from '../../components/animationIntersector';\nimport rootScope from '../rootScope';\nimport wrapRichText from './wrapRichText';\n\nexport default function wrapDraftText(text: string, options: Partial<{\n  wrappingForPeerId: PeerId,\n  animationGroup?: AnimationItemGroup\n}> & Parameters<typeof wrapRichText>[1] = {}) {\n  if(!text) {\n    return wrapRichText('');\n  }\n\n  let entities = options.entities;\n  if(entities && !rootScope.premium && options.wrappingForPeerId !== rootScope.myId) {\n    entities = entities.filter((entity) => entity._ !== 'messageEntityCustomEmoji');\n  }\n\n  const fragment = wrapRichText(text, {\n    ...options,\n    entities,\n    noLinks: true,\n    wrappingDraft: true,\n    passEntities: {\n      messageEntityTextUrl: true,\n      messageEntityMentionName: true\n    }\n  });\n\n  return fragment;\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type CustomEmojiElement from '../lib/customEmoji/element';\nimport type {AnimationItemGroup} from './animationIntersector';\nimport {CustomEmojiRendererElement} from '../lib/customEmoji/renderer';\nimport cancelEvent from '../helpers/dom/cancelEvent';\nimport simulateEvent from '../helpers/dom/dispatchEvent';\nimport documentFragmentToHTML from '../helpers/dom/documentFragmentToHTML';\nimport findUpAttribute from '../helpers/dom/findUpAttribute';\nimport findUpTag from '../helpers/dom/findUpTag';\nimport getCaretPosNew from '../helpers/dom/getCaretPosNew';\nimport getRichValueWithCaret from '../helpers/dom/getRichValueWithCaret';\nimport isInputEmpty from '../helpers/dom/isInputEmpty';\nimport replaceContent from '../helpers/dom/replaceContent';\nimport RichInputHandler, {USING_BOMS} from '../helpers/dom/richInputHandler';\nimport selectElementContents from '../helpers/dom/selectElementContents';\nimport setInnerHTML, {setDirection} from '../helpers/dom/setInnerHTML';\nimport {MessageEntity} from '../layer';\nimport {i18n, LangPackKey, _i18n} from '../lib/langPack';\nimport {NULL_PEER_ID} from '../lib/mtproto/mtproto_config';\nimport mergeEntities from '../lib/richTextProcessor/mergeEntities';\nimport parseEntities from '../lib/richTextProcessor/parseEntities';\nimport wrapDraftText from '../lib/richTextProcessor/wrapDraftText';\nimport {createCustomFiller, insertCustomFillers} from '../lib/richTextProcessor/wrapRichText';\nimport type {MarkupTooltipTypes} from './chat/markupTooltip';\n\nexport async function insertRichTextAsHTML(input: HTMLElement, text: string, entities: MessageEntity[], wrappingForPeerId: PeerId) {\n  const loadPromises: Promise<any>[] = [];\n  const wrappingCustomEmoji = entities?.some((entity) => entity._ === 'messageEntityCustomEmoji');\n  const renderer = wrappingCustomEmoji ? createCustomEmojiRendererForInput() : undefined;\n  const fragment = wrapDraftText(text, {entities, wrappingForPeerId, loadPromises, customEmojiRenderer: renderer});\n  const something = fragment.querySelectorAll<HTMLElement>('[contenteditable=\"false\"]');\n  something.forEach((el) => {\n    el.contentEditable = 'inherit';\n    el.classList.add('pc');\n  });\n\n  loadPromises.length && await Promise.all(loadPromises);\n\n  fragment.querySelectorAll<HTMLElement>('.input-selectable').forEach((el) => {\n    el.prepend(createCustomFiller(true));\n  });\n\n  const richInputHandler = USING_BOMS ? RichInputHandler.getInstance() : undefined;\n  // const restore = richInputHandler.prepareApplyingMarkdown();\n\n  // fragment.querySelectorAll('.input-filler').forEach((el) => el.remove());\n\n  // const fillers = Array.from(input.querySelectorAll<HTMLElement>('.input-filler')).map((el) => {\n  //   el.contentEditable = 'false';\n  //   return el;\n  // });\n\n  const customEmojiElements = Array.from(fragment.querySelectorAll<HTMLImageElement>('.custom-emoji-placeholder')).map((el) => {\n    el.dataset.ces = '1';\n    return (el as any).customEmojiElement as CustomEmojiElement;\n  });\n\n  const html = documentFragmentToHTML(fragment);\n  renderer?.destroy();\n\n  // console.log(html);\n\n  const pre = getCaretPosNew(input);\n  // console.log('pre', pre);\n  let textNode: ChildNode, textNodeValue: string;\n  if(pre.node) {\n    // if(pre.node?.nodeValue === BOM && false) {\n    //   textNode = document.createTextNode(textNodeValue = BOM);\n    //   (pre.node.parentNode as any as ChildNode).after(textNode);\n    //   pre.selection.modify('extend', 'forward', 'character');\n    //   pre.selection.collapseToEnd();\n    // }\n  } else {\n    const range = document.createRange();\n    let node = input.lastChild;\n    if(!node) {\n      input.append(node /* = textNode */ = document.createTextNode(''));\n    }\n\n    range.setStartAfter(node);\n    range.collapse(true);\n    pre.selection.removeAllRanges();\n    pre.selection.addRange(range);\n  }\n\n  // const fragmentLastChild = fragment.lastChild;\n\n  // const s = document.createElement('span');\n  // (node as ChildNode).replaceWith(s);\n  // s.append(node);\n  input.addEventListener('input', cancelEvent, {capture: true, once: true, passive: false});\n  richInputHandler?.onBeforeInput({inputType: 'insertContent'});\n  window.document.execCommand('insertHTML', false, html);\n  Array.from(input.querySelectorAll<HTMLImageElement>('[data-ces]')).forEach((el, idx) => {\n    delete el.dataset.ces;\n    const customEmojiElement = customEmojiElements[idx];\n    (el as any).customEmojiElement = customEmojiElement;\n    customEmojiElement.placeholder = el;\n  });\n  // fillers.forEach((el) => {\n  //   el.contentEditable = 'inherit';\n  // });\n  input.querySelectorAll<HTMLElement>('.pc').forEach((el) => {\n    el.contentEditable = 'false';\n  });\n  if(textNode) {\n    const {nodeValue} = textNode;\n    if(nodeValue === textNodeValue) {\n      textNode.remove();\n    } else {\n      (textNode as CharacterData).replaceData(nodeValue.indexOf(textNodeValue), textNodeValue.length, '');\n    }\n  }\n  // restore();\n  richInputHandler?.removeExtraBOMs(input);\n  simulateEvent(input, 'input');\n\n  // if(textNode) {\n  //   const selection = document.getSelection();\n  //   const node = fragmentLastChild.nextSibling || fragmentLastChild;\n  //   const range = document.createRange();\n  //   range.setStartAfter(node);\n  //   range.collapse(true);\n  //   selection.removeAllRanges();\n  //   selection.addRange(range);\n  // }\n\n  // const after = getCaretPosNew(input);\n  // console.log('after', after);\n  // if(after.node?.nodeValue === BOM) {\n  //   const smth = findUpClassName(after.node.parentElement, 'input-something');\n  //   if(smth) {\n  //     const selection = document.getSelection();\n  //     const node = smth.nextSibling;\n  //     const range = document.createRange();\n  //     range.setStartAfter(node);\n  //     range.collapse(true);\n  //     selection.removeAllRanges();\n  //     selection.addRange(range);\n\n  //     // if(after.offset === 0) after.selection.modify('extend', 'forward', 'character');\n  //     // after.selection.modify('extend', 'forward', 'character');\n  //     // after.selection.collapseToEnd();\n  //   }\n  // }\n\n  // setCaretAt(fragmentLastChild.nextSibling);\n\n  // console.log('ASD');\n}\n\nlet init = () => {\n  document.addEventListener('paste', (e) => {\n    const input = findUpAttribute(e.target, 'contenteditable=\"true\"');\n    if(!input) {\n      return;\n    }\n\n    const noLinebreaks = !!input.dataset.noLinebreaks;\n    e.preventDefault();\n    let text: string, entities: MessageEntity[];\n\n    // @ts-ignore\n    let plainText: string = (e.originalEvent || e).clipboardData.getData('text/plain').replace(/\\r/g, '');\n    let usePlainText = true;\n\n    // @ts-ignore\n    let html: string = (e.originalEvent || e).clipboardData.getData('text/html') || plainText;\n\n    const filterEntity = (e: MessageEntity) => e._ === 'messageEntityEmoji' || (e._ === 'messageEntityLinebreak' && !noLinebreaks);\n    if(noLinebreaks) {\n      const regExp = /[\\r\\n]/g;\n      plainText = plainText.replace(regExp, '');\n      html = html.replace(regExp, '');\n    }\n\n    const peerId = (input.dataset.peerId || NULL_PEER_ID).toPeerId();\n    if(html.trim()) {\n      // console.log(html.replace(/ (style|class|id)=\".+?\"/g, ''));\n\n      html = html.replace(/<style([\\s\\S]*)<\\/style>/, '');\n      html = html.replace(/<!--([\\s\\S]*?)-->/g, '');\n      html = html.replace('<br class=\"Apple-interchange-newline\">', '');\n      html = html.replace(/\\r/g, '');\n\n      const match = html.match(/<body>([\\s\\S]*)<\\/body>/);\n      if(match) {\n        html = match[1].trim();\n      }\n\n      // const s = cleanHTML(html, true) as NodeList;\n      // console.log(s);\n\n      const parser = new DOMParser();\n      const doc = parser.parseFromString(html, 'text/html');\n      const span = doc.body || document.createElement('body');\n\n      // const span: HTMLElement = document.createElement('span');\n      // span.innerHTML = html;\n      // span.append(...Array.from(s));\n\n      let curChild = span.firstChild;\n      while(curChild) { // * fix whitespace between elements like <p>asd</p>\\n<p>zxc</p>\n        const nextSibling = curChild.nextSibling;\n        if(curChild.nodeType === curChild.TEXT_NODE) {\n          if(!curChild.nodeValue.trim()) {\n            curChild.remove();\n          }\n        }\n\n        curChild = nextSibling;\n      }\n\n      const richValue = getRichValueWithCaret(span, true, false);\n\n      const canWrapCustomEmojis = !!peerId;\n      if(!canWrapCustomEmojis) {\n        richValue.entities = richValue.entities.filter((entity) => entity._ !== 'messageEntityCustomEmoji');\n      }\n\n      /* if(false) */ { // * fix extra new lines appearing from <p> (can have them from some sources, like macOS Terminal)\n        const lines = richValue.value.split('\\n');\n        let textLength = 0;\n        for(let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n          const line = lines[lineIndex];\n          textLength += line.length;\n\n          const index = textLength;\n          if(plainText[index] !== '\\n' && lineIndex !== (lines.length - 1)) {\n            const nextLine = lines.splice(lineIndex + 1, 1)[0];\n            lines[lineIndex] = line + nextLine;\n\n            // fix entities\n            richValue.entities.forEach((entity) => {\n              if(entity.offset >= index) {\n                entity.offset -= 1;\n              }\n            });\n\n            textLength += nextLine.length;\n          }\n\n          textLength += 1;\n        }\n\n        const correctedText = lines.join('\\n');\n        richValue.value = correctedText;\n      }\n\n      const richTextLength = richValue.value.replace(/\\s/g, '').length;\n      const plainTextLength = plainText.replace(/\\s/g, '').length;\n      if(richTextLength === plainTextLength ||\n        richValue.entities.find((entity) => entity._ === 'messageEntityCustomEmoji')) {\n        text = richValue.value;\n        entities = richValue.entities;\n        usePlainText = false;\n\n        let entities2 = parseEntities(text);\n        entities2 = entities2.filter(filterEntity);\n        entities = mergeEntities(entities, entities2);\n      }\n\n      // console.log('usePlainText', usePlainText);\n    }\n\n    if(usePlainText) {\n      text = plainText;\n      entities = parseEntities(text);\n      entities = entities.filter(filterEntity);\n    }\n\n    insertRichTextAsHTML(input, text, entities, peerId);\n  });\n\n  init = null;\n};\n\n// ! it doesn't respect symbols other than strongs\n/* const checkAndSetRTL = (input: HTMLElement) => {\n  //const isEmpty = isInputEmpty(input);\n  //console.log('input', isEmpty);\n\n  //const char = [...getRichValue(input)][0];\n  const char = (input instanceof HTMLInputElement ? input.value : input.innerText)[0];\n  let direction = 'ltr';\n  if(char && checkRTL(char)) {\n    direction = 'rtl';\n  }\n\n  //console.log('RTL', direction, char);\n\n  input.style.direction = direction;\n}; */\n\nexport enum InputState {\n  Neutral = 0,\n  Valid = 1,\n  Error = 2\n};\n\nexport type InputFieldOptions = {\n  placeholder?: LangPackKey,\n  placeholderAsElement?: boolean,\n  label?: LangPackKey,\n  labelOptions?: any[],\n  labelText?: string | DocumentFragment,\n  name?: string,\n  maxLength?: number,\n  showLengthOn?: number,\n  plainText?: true,\n  required?: boolean,\n  canBeEdited?: boolean,\n  validate?: () => boolean,\n  inputMode?: 'tel' | 'numeric',\n  withLinebreaks?: boolean,\n  autocomplete?: string,\n  withBorder?: boolean,\n  allowStartingSpace?: boolean,\n  onRawInput?: (value: string) => void,\n  canHaveFormatting?: Array<MarkupTooltipTypes>\n};\n\nfunction createCustomEmojiRendererForInput(textColor?: string, animationGroup?: AnimationItemGroup) {\n  const renderer = CustomEmojiRendererElement.create({\n    wrappingDraft: true,\n    isSelectable: true,\n    textColor: textColor || 'primary-text-color',\n    animationGroup\n  });\n\n  return renderer;\n}\n\nfunction processCustomEmojisInInput(input: HTMLElement) {\n  const customEmojiElements = Array.from(input.querySelectorAll<CustomEmojiElement | HTMLElement>('.custom-emoji, .custom-emoji-placeholder'));\n  let renderer = input.querySelector<CustomEmojiRendererElement>('.custom-emoji-renderer');\n  if(!renderer && customEmojiElements.length) {\n    renderer = createCustomEmojiRendererForInput(input.dataset.textColor, input.dataset.animationGroup as AnimationItemGroup);\n    input.prepend(renderer);\n  } else if(renderer && !customEmojiElements.length) {\n    renderer.remove();\n    return;\n  }\n\n  if(!renderer) {\n    return;\n  }\n\n  const customEmojis: Parameters<CustomEmojiRendererElement['add']>[0]['addCustomEmojis'] = new Map();\n  customEmojiElements.forEach((element) => {\n    const customEmojiElement: CustomEmojiElement = (element as CustomEmojiElement).loop !== undefined ? element as CustomEmojiElement : (element as any).customEmojiElement as CustomEmojiElement;\n    const {docId} = customEmojiElement;\n    let set = customEmojis.get(docId);\n    if(!set) {\n      customEmojis.set(docId, set = new Set());\n    }\n\n    set.add(customEmojiElement);\n  });\n\n  for(const [docId, customEmojiElements] of customEmojis) {\n    let hasSet = renderer.customEmojis.get(docId);\n    if(hasSet) {\n      for(const customEmojiElement of hasSet) {\n        if(!customEmojiElements.has(customEmojiElement)) {\n          customEmojiElement.destroy();\n        }\n      }\n    } else {\n      hasSet = new Set();\n    }\n\n    for(const customEmojiElement of customEmojiElements) {\n      if(!hasSet.has(customEmojiElement)) {\n        customEmojiElement.connectedCallback();\n      }\n    }\n  }\n\n  renderer.add({\n    addCustomEmojis: customEmojis,\n    lazyLoadQueue: false\n  });\n  renderer.forceRender();\n}\n\nexport default class InputField {\n  public container: HTMLElement;\n  public input: HTMLElement;\n  public label: HTMLLabelElement;\n  public placeholder: HTMLElement;\n\n  public originalValue: string;\n\n  public required: boolean;\n  public validate: () => boolean;\n\n  public allowStartingSpace: boolean;\n\n  constructor(public options: InputFieldOptions = {}) {\n    this.container = document.createElement('div');\n    this.container.classList.add('input-field');\n\n    this.required = options.required;\n    this.validate = options.validate;\n\n    if(options.maxLength !== undefined && options.showLengthOn === undefined) {\n      options.showLengthOn = Math.min(40, Math.round(options.maxLength / 3));\n    }\n\n    const {placeholder, maxLength, showLengthOn, name, plainText, canBeEdited = true, autocomplete, withBorder, allowStartingSpace, canHaveFormatting} = options;\n    const label = options.label || options.labelText;\n    this.allowStartingSpace = allowStartingSpace;\n\n    const onInputCallbacks: Array<() => void> = [];\n    let input: HTMLElement;\n    if(!plainText) {\n      if(init) {\n        init();\n      }\n\n      this.container.innerHTML = `<div class=\"input-field-input\"></div>`;\n\n      input = this.container.firstElementChild as HTMLElement;\n      input.contentEditable = '' + !!canBeEdited;\n      // const observer = new MutationObserver(() => {\n      //   //checkAndSetRTL(input);\n\n      //   if(processInput) {\n      //     processInput();\n      //   }\n      // });\n\n      RichInputHandler.getInstance();\n\n      input.addEventListener('mousedown', (e) => {\n        const selection = document.getSelection();\n        if(!selection.isCollapsed) {\n          return;\n        }\n\n        const placeholder = findUpTag(e.target, 'IMG');\n        if(!placeholder) {\n          return;\n        }\n\n        const rect = placeholder.getBoundingClientRect();\n        const centerX = rect.left + rect.width / 2;\n        const focusOnNext = e.clientX >= centerX;\n\n        const range = document.createRange();\n        range.setStartAfter(focusOnNext ? placeholder : placeholder.previousSibling ?? placeholder);\n        selection.removeAllRanges();\n        selection.addRange(range);\n      });\n\n      if(canHaveFormatting) {\n        input.setAttribute('can-format', canHaveFormatting.join(','));\n      }\n\n      onInputCallbacks.push(() => {\n        // console.log('input');\n        // return;\n        // * because if delete all characters there will br left\n        const isEmpty = this.isEmpty();\n        if(isEmpty) {\n          // const textNode = Array.from(input.childNodes).find((node) => node.nodeType === node.TEXT_NODE) || document.createTextNode('');\n          input.replaceChildren();\n          // input.append(document.createTextNode('')); // need first text node to support history stack\n        }\n\n        this.setEmpty(isEmpty);\n\n        // const fillers = Array.from(input.querySelectorAll('.emoji-filler')) as HTMLElement[];\n        // fillers.forEach((filler) => {\n        //   const textContent = filler.textContent;\n        //   if(textContent === BOM) {\n        //     return;\n        //   }\n\n        //   if(textContent) {\n\n        //   } else {\n        //     let curChild = filler.firstChild;\n        //     while(curChild) {\n        //       curChild = curChild.nextSibling;\n        //     }\n        //   }\n\n        //   filler.classList.remove('emoji-filler');\n        // });\n\n        // Array.from(input.querySelectorAll('br, span:empty')).forEach((el) => {\n        //   const parentElement = el.parentElement;\n        //   (parentElement === input ? el : parentElement).remove();\n        // });\n        USING_BOMS && Array.from(input.querySelectorAll('br:not(.br-not-br)')).forEach((el) => {\n          // const parentElement = el.parentElement;\n          el.remove();\n          // if(!parentElement.children.length && !parentElement.textContent) {\n          //   parentElement.textContent = '';\n          // }\n        });\n\n        insertCustomFillers(Array.from(input.querySelectorAll('.input-something')));\n\n        processCustomEmojisInInput(input);\n\n        // .forEach((el) => el.remove());\n      });\n\n      // ! childList for paste first symbol\n      // observer.observe(input, {characterData: true, childList: true, subtree: true});\n    } else {\n      this.container.innerHTML = `\n      <input type=\"text\" ${name ? `name=\"${name}\"` : ''} autocomplete=\"${autocomplete ?? 'off'}\" ${label ? 'required=\"\"' : ''} class=\"input-field-input\">\n      `;\n\n      input = this.container.firstElementChild as HTMLElement;\n      // input.addEventListener('input', () => checkAndSetRTL(input));\n\n      onInputCallbacks.push(() => {\n        const isEmpty = this.isEmpty();\n        if(isEmpty) {\n          (input as HTMLInputElement).value = '';\n        }\n\n        this.setEmpty(isEmpty);\n      });\n    }\n\n    setDirection(input);\n\n    if(options.inputMode) {\n      input.inputMode = options.inputMode;\n    }\n\n    if(placeholder) {\n      // if(options.placeholderAsElement) {\n      this.placeholder = document.createElement('span');\n      this.placeholder.classList.add('input-field-placeholder');\n      this.container.append(this.placeholder);\n      _i18n(this.placeholder, placeholder, undefined);\n      // } else {\n      //   _i18n(input, placeholder, undefined, 'placeholder');\n      // }\n    }\n\n    if(withBorder !== false && withBorder || label || placeholder) {\n      const border = document.createElement('div');\n      border.classList.add('input-field-border');\n      this.container.append(border);\n    }\n\n    if(label) {\n      this.label = document.createElement('label');\n      this.setLabel();\n      this.container.append(this.label);\n    }\n\n    if(maxLength) {\n      const labelEl = this.container.lastElementChild as HTMLLabelElement;\n      let showingLength = false;\n\n      const onInput = () => {\n        const wasError = input.classList.contains('error');\n        // * https://stackoverflow.com/a/54369605 #2 to count emoji as 1 symbol\n        const inputLength = plainText ? (input as HTMLInputElement).value.length : [...getRichValueWithCaret(input, false, false).value].length;\n        const diff = maxLength - inputLength;\n        const isError = diff < 0;\n        input.classList.toggle('error', isError);\n\n        // this.onLengthChange && this.onLengthChange(inputLength, isError);\n\n        if(isError || diff <= showLengthOn) {\n          this.setLabel();\n          labelEl.append(` (${maxLength - inputLength})`);\n          if(!showingLength) showingLength = true;\n        } else if((wasError && !isError) || showingLength) {\n          this.setLabel();\n          showingLength = false;\n        }\n      };\n\n      onInputCallbacks.push(onInput);\n    }\n\n    const noLinebreaks = !options.withLinebreaks;\n    if(noLinebreaks && !plainText) {\n      input.dataset.noLinebreaks = '1';\n      input.addEventListener('keypress', (e) => {\n        if(e.key === 'Enter') {\n          e.preventDefault();\n          return false;\n        }\n      });\n    }\n\n    if(options.onRawInput) {\n      onInputCallbacks.push(() => {\n        options.onRawInput(this.value);\n      });\n    }\n\n    if(onInputCallbacks.length) {\n      input.addEventListener('input', () => {\n        onInputCallbacks.forEach((callback) => callback());\n      });\n    }\n\n    this.input = input;\n    this.setEmpty(true);\n  }\n\n  public select() {\n    if(!this.value) { // * avoid selecting whole empty field on iOS devices\n      return;\n    }\n\n    if(this.options.plainText) {\n      (this.input as HTMLInputElement).select(); // * select text\n    } else {\n      selectElementContents(this.input);\n    }\n  }\n\n  public setLabel() {\n    this.label.textContent = '';\n    if(this.options.labelText) {\n      setInnerHTML(this.label, this.options.labelText);\n    } else {\n      this.label.append(i18n(this.options.label, this.options.labelOptions));\n    }\n  }\n\n  get value(): string {\n    return this.options.plainText ? (this.input as HTMLInputElement).value : getRichValueWithCaret(this.input, false, false).value;\n    // return getRichValue(this.input);\n  }\n\n  set value(value: Parameters<typeof replaceContent>[1]) {\n    this.setValueSilently(value, true);\n    this.simulateInputEvent();\n  }\n\n  public simulateInputEvent() {\n    simulateEvent(this.input, 'input');\n  }\n\n  public setValueSilently(value: Parameters<typeof replaceContent>[1], fromSet?: boolean) {\n    if(this.options.plainText) {\n      (this.input as HTMLInputElement).value = value as string;\n    } else {\n      replaceContent(this.input, value);\n      processCustomEmojisInInput(this.input);\n    }\n\n    this.setEmpty();\n  }\n\n  private setEmpty = (empty = this.isEmpty()) => {\n    [this.input, this.placeholder].filter(Boolean).forEach((el) => {\n      el.classList.toggle('is-empty', empty);\n    });\n  };\n\n  public isEmpty() {\n    return isInputEmpty(this.input, this.allowStartingSpace);\n  }\n\n  public isChanged() {\n    return this.value !== this.originalValue;\n  }\n\n  public isValid() {\n    return !this.input.classList.contains('error') &&\n      (!this.validate || this.validate()) &&\n      (!this.required || !this.isEmpty());\n  }\n\n  public isValidToChange() {\n    return this.isValid() && this.isChanged();\n  }\n\n  public setDraftValue(value = '', silent?: boolean) {\n    let _value: Parameters<typeof replaceContent>[1] = value;\n    if(!this.options.plainText) {\n      _value = /* documentFragmentToHTML */(wrapDraftText(value));\n    }\n\n    if(silent) {\n      this.setValueSilently(_value, false);\n    } else {\n      this.value = _value;\n    }\n  }\n\n  public setOriginalValue(value: InputField['originalValue'] = '', silent?: boolean) {\n    this.originalValue = value;\n    this.setDraftValue(value, silent);\n  }\n\n  public setState(state: InputState, label?: LangPackKey) {\n    if(label) {\n      this.label.textContent = '';\n      this.label.append(i18n(label, this.options.labelOptions));\n    } else {\n      this.setLabel();\n    }\n\n    this.input.classList.toggle('error', !!(state & InputState.Error));\n    this.input.classList.toggle('valid', !!(state & InputState.Valid));\n  }\n\n  public setError(label?: LangPackKey) {\n    this.setState(InputState.Error, label);\n  }\n}\n"],"names":["placeCaretAtEnd","el","ignoreTouchCheck","focus","IS_TOUCH_SUPPORTED","length","range","sel","documentFragmentToHTML","fragment","node","encodeEntities","findUpAttribute","attribute","findUpTag","tag","getCaretPosNew","input","anchor","selection","offset","findUpAsChild","getCaretPosF","childNodes","childNodesLength","CAN_COMBINE_ENTITIES","combineSameEntities","entities","i","entity","nextEntityIdx","e","_i","nextEntity","sortEntities","a","b","markdownTags","tabulationMatch","BLOCK_TAGS","BOM_REG_EXP","BOM","SELECTION_SEPARATOR","checkNodeForEntity","value","parentElement","type","closest","codeElement","isLineEmpty","line","getRichElementValue","lines","selNode","selOffset","nodeValue","pushLine","isSelected","isQuote","isBlock","alt","stickerEmoji","isTableCell","wasEntitiesLength","wasNodeEmpty","curChild","lastValue","getCaretPos","field","startOffset","possibleChildrenFocusOffset","getRichValueWithCaret","withEntities","withCaret","caretPos","MOUNT_CLASS_TO","isInputEmpty","element","allowStartingSpace","compareNodes","node1","node1Offset","node2","node2Offset","diff","whichChild","parents","commonAncestorContainer","clamp","NOT_ONLY_BOMS_REG_EXP","RichInputHandler","caret","move","toLeft","log","addInputCallback","moveFirst","c","isBOM","key","logger","ListenerSetter","something","elements","index","fromSelectionChange","smthIndex","idx","moved","idxidx","rangeString","onlyBOMs","br","callback","capture","newCallback","IS_FIREFOX","sibling","previousSibling","nextSibling","needed","isCustomFillerNeededBySiblingNode","ret","treeWalker","textNode","cleanSiblings","t","bomNode","left","focusNodeBefore","focusOffsetBefore","focusNodeAfter","focusOffsetAfter","fillers","smths","selectElementContents","SINGLE_ENTITIES","findConflictingEntity","currentEntities","newEntity","singleStart","singleEnd","currentEntity","PASS_SINGLE_CONFLICTING_ENTITIES","PASS_CONFLICTING_ENTITIES","mergeEntities","newEntities","filtered","wrapDraftText","text","options","wrapRichText","rootScope","insertRichTextAsHTML","wrappingForPeerId","loadPromises","renderer","createCustomEmojiRendererForInput","createCustomFiller","customEmojiElements","html","pre","cancelEvent","customEmojiElement","simulateEvent","init","noLinebreaks","plainText","usePlainText","filterEntity","regExp","peerId","NULL_PEER_ID","match","span","richValue","textLength","lineIndex","nextLine","correctedText","richTextLength","plainTextLength","entities2","parseEntities","InputState","textColor","animationGroup","CustomEmojiRendererElement","processCustomEmojisInInput","customEmojis","docId","set","hasSet","InputField","empty","placeholder","maxLength","showLengthOn","name","canBeEdited","autocomplete","withBorder","canHaveFormatting","label","onInputCallbacks","isEmpty","rect","centerX","focusOnNext","insertCustomFillers","setDirection","_i18n","border","labelEl","showingLength","onInput","wasError","inputLength","isError","setInnerHTML","i18n","fromSet","replaceContent","silent","_value","state"],"mappings":"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"}